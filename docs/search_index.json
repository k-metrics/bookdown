[
["index.html", "Rのすゝめ - Rによるデータ分析事始め - Welcome", " Rのすゝめ - Rによるデータ分析事始め - Sampo Suzuki, CC 4.0 BY-NC-SA 2020-01-25 Welcome ソフトウェア開発において「データに基づく品質管理」が必要と言われるようになってから久しくなりますが、様々な理由でデータに基づく管理を実践している組織はまだまだ少数派ではないでしょうか？しかし、世の中の流れは「データドリブン」というキーワードに代表されるようにデータを使いこなせる組織が優位に立てる時代、数理資本主義の時代と言われています。 『データ指向のソフトウェア品質マネジメント』 は、日本のソフトウェア品質管理におけるデータドリブン管理の必要性とデータドリブン管理に必要な知識を解説している数少ない書籍です。著者の一人である小池氏が主催している データ分析勉強会 では、メトリクス分析に興味をもつ有志がデータドリブン管理を実践するために様々な分析知識や手法を学んでいます。 本書は実務でメトリクス分析を行うソフトウェア品質技術者をはじめとした R を学んでデータ分析をしたい方々を想定読者として R の基本的な知識を紹介しています。データ分析勉強会を通じて学んだ分析手法を実務で実践したい方の助けになれば幸いです。 本書は クリエイティブ・コモンズ 表示 - 非営利 - 継承 4.0 国際 ライセンス の下に提供されています。 あなたの従うべき条件は以下の通りです。 表示 あなたは 適切なクレジットを表示し、ライセンスへのリンクを提供し、変更があったらその旨を示さなければなりません。これらは合理的であればどのような方法で行っても構いませんが、許諾者があなたやあなたの利用行為を支持していると示唆するような方法は除きます。 非営利 あなたは営利目的でこの資料を利用してはなりません。 継承 もしあなたがこの資料をリミックスしたり、改変したり、加工した場合には、あなたはあなたの貢献部分を元の作品と同じライセンスの下に頒布しなければなりません。 CC 4.0 BY-NC-SA "],
["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction データ分析を行うためには適切な分析ツールが必要不可欠です。 R は統計計算に特化しているオープンソースの言語でデータ分析に適切な分析ツールのひとつです。R がデータ分析に向いている理由をまとめているのが “Six Reasons To Learn R For Business”, R Blogger です。 R Has The Best Overall Qualities R Is Data Science For Non-Computer Scientists Learning R Is Easy With The Tidyverse R Has Brains, Muscle, And Heart R Is Built For Business R Community Support R はデータ分析に必要となるデータのハンドリングや可視化、モデリング、そして、レポーティングといった様々な機能を無料で利用することができます。また、R は逐次実行のインタプリタ型言語ですのでソフトウェアメトリクス分析のようなアドホック分析に適していると言えます。さらに、非常にフレンドリーかつ活発なコミュニティーが日本でも形成されていますので、悩んだ時などに気軽に質問・相談ができるのも大きな強みです。 "],
["data-science-workflow.html", "1.1 Data Science Workflow", " 1.1 Data Science Workflow データ分析の方法は様々ですが、そのプロセスは下図のように抽象化することができます。 図出典：RStartHere, RStudio, inc. この図は「Data Science Workflow」と呼ばれ、R コミュニティに多大な貢献をしている Hadley Wickham の著書 『R for Data Science』 で使われている図が元になっています。 本書では、この Data Science Workflow に基づくページ構成になっており各プロセスのスコープ概略は下記の通りです。 Program データ分析のすべてのプロセス（Tidy 〜 Communicate/Automate）で必要となるツールがプログラミングです。プログラミングを覚えることで効率的に分析処理を行えるようになります。 Import 分析対象となるデータを分析環境に取り込み分析をできるようにするのがインポートプロセスです。データは様々な形式（文字コード、ファイル形式など）で保存されていますので、それらに見合った方法でインポートする必要があります。 Tidy インポートしたデータは必ずしもデータ分析に適した形式になっているとは限りませんので、一貫した形式（Tidy data）に整理します。 Tidy data はデータ分析において重要な概念です。 Transform 整理したデータ（Tidy data）がそのまま状態でデータ分析に使えることは稀です。不要なデータを削除したり（クレンジング）、必要なデータだけに絞り込んだり、新しい変数を計算したりする必要があります。 Tidy プロセスと合わせて Wrangle や Data wrangling、前処理と呼ばれることもあります。 Visualize データを可視化することは様々な示唆を得ることと同義といえます。分析方針を考えるためにもデータがどういう傾向をもっているのかを把握するためのプロセスともいえます。 Model/Infer 可視化で得られた情報を元に数式可（モデル化）するのプロセスです。モデルは様々な Communicate/Automate 分析結果を他人に伝えるためのプロセスです。結果を他人に伝えるだけでは不十分で 再現可能性（Reproducible research） が伴っていることも求められます。 "],
["install.html", "Chapter 2 Install", " Chapter 2 Install R について学ぶ前に R が使えるように環境を整えます。本書は R, RStudio, Tidyverse/ パッケージならびに他のパッケージの利用を前提としています。 R ならびに RStudio はマルチプラットフォーム対応ですので、プラットフォームは Windows, macOS, Linux のどのプラットフォームでも構いませんが、日本語版 Windows ではプラットフォームが使用している文字コードに起因する不具合（日本語が表示されないなど）が発生する可能性があります。 環境を整えるための手順は以下のようになります。 手順 実施内容 備考 1 Rのインストール 2 Rtoolsのインストール Winodwsのみ 3 RStudioのインストール Desktop版 4 パッケージのインストール 5 Gitのインストール Git は VCS(Version Control System) と呼ばれるソースの版管理を行うシステムです。必要な場合のみインストールしてください。 "],
["install-r.html", "2.1 Install R", " 2.1 Install R R は CRAN (The Comprehensive R Archive Network) と呼ばれる公式リポジトリから入手してインストールします。 2.1.1 Windows Winodws では特段の理由がない限り CRAN から最新バージョンをインストールしてください。 2.1.1.1 Rtools Windows ではコンパイラなどの開発ツール類が標準装備されていませんので R のパッケージをインストールする際に必要となるツールキットを別途インストールしておく必要があります。 Rtools からインストールした R のバージョン用の Rtools をダウンロードしてインストールしてください。 2.1.2 macOS (OS X) macOS ではインストールできるバージョンが限られていますので CRAN で確認の上、インストールしてください。 2.1.3 Linux R がサポートしているディストリビューションは Debian, RedHat, Suse, Ubuntu のみです。Fedora を利用したい場合には README を参照の上でRedHat Software のリポジトリからインストールしてください。 Linux の場合、ディストリビューションごと・バージョンごとにインストール方法が異なりますので CRAN を参考にインストールしてください。 "],
["install-rstudio-desktop.html", "2.2 Install RStudio Desktop", " 2.2 Install RStudio Desktop R のインストールが完了したら統合開発環境（IDR）である RStudio Desktop をインストールします。 Downloadページ から使用している環境（OS）用の RStudio をダウンロードしてインストールしてください。 2.2.1 動作確認 RStudio のインストールが完了したら RStudio を起動します。下図のようなウィンドウが立ち上がり左側の Console ペインに R のバージョンなどが表示されます。 Console ペインのプロンプト（&gt;表示）の部分に2 * 3と打ち込んで［Enter］キーを押し[1] 6と表示されることを確認してください。 2 * 3 [1] 6 "],
["install-r-packages.html", "2.3 Install R packages", " 2.3 Install R packages 次に必要となるいくつかのパッケージをインストールします。パッケージをインストールする場合はインターネットに接続されている必要があります。 Console ペインのプロンプトに以下のコードを入力し [Enter]キーを押して実行します。 install.packages(&quot;tidyverse&quot;) インストールが終わりましたらパッケージが正しくインストールされていることを確認するために Console ペインに以下のコードを入力して実行します。 library(tidyverse) 以下のようなメッセージが表示されることを確認します。なお、インストール時期によってはバージョン表記などが下記と異なる場合があります。また、Windows 環境では一部の文字が化けします。 Loading required package: tidyverse ─ Attaching packages ─────────────────────────────── tidyverse 1.3.0 ─ ✔ ggplot2 3.2.1 ✔ purrr 0.3.3 ✔ tibble 2.1.3 ✔ dplyr 0.8.3 ✔ tidyr 1.0.0 ✔ stringr 1.4.0 ✔ readr 1.3.1 ✔ forcats 0.4.0 ─ Conflicts ───────────────────────────────── tidyverse_conflicts() ─ ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() "],
["install-git.html", "2.4 Install Git", " 2.4 Install Git RStudio には版管理インタフェースが標準で用意されていますが、版管理システム（以降、VCS）自体は別途インストールする必要があります。RStudio で利用できる VCS は以下の二つです。 * Git * Subversion(SVN) Git の方が GitHub などのクラウドサービスが充実していますので、これから版管理を利用する場合は Git の利用をおすゝめします。 2.4.1 Git Windows および macOS は Gitの ダウンロードページ から最新バージョンをダウンロードしてインストールします。Linux はリポジトリからインストールするか ダウンロードページ から最新バージョンをダウンロードしてインストールしてください。 2.4.2 Git Client RStudio には簡易的な Git のクライアント機能が標準で用意されていますが、きめ細かな操作を行いたい場合には Git の GUI クライアントをインストールしてください。 Git GUI Client Ubuntu Mac Windows Memo GitKraken Yes Yes Yes Free版は機能制限あり SmartGit Yes Yes Yes Free版でも機能制限なし1 GitEye Yes Yes Yes Sourcetree No Yes Yes 日本語版あり GitHub Desktop No Yes Yes 1 : 非商用利用の場合 "],
["rstudio-server.html", "2.5 RStudio Server", " 2.5 RStudio Server R/Rstudio Desktop はマルチプラットフォーム対応ですがプラットフォーム（OS）ごとに以下のような制約があります。 日本語版 Windows 環境では文字コード変換が原因で日本語を正しく処理できないことが多い 18.04LTSより前の Ubuntu 環境では RStudio Desktop で日本語入力ができない * 有志による日本語入力パッチがリリースされている 特に日本語版 Windows 環境はシフト JIS （CP932） を使っているため日本語処理の問題は根本的な解決を期待できません。 Web サーバベースで動作する RStudio Server を利用することで、このような日本語に関わる問題を一掃することができます。 Docker のコンテナ技術を利用することで、Windows（要 Hyper-V または WSL2）・ macOS ・ Linux の各プラットフォームで統一された環境として動作させることが可能です。 "],
["rstudio-ide.html", "Chapter 3 RStudio IDE", " Chapter 3 RStudio IDE データ分析勉強会ではながらく R Commander（以降、Rcmdr） が利用されています。Rcmdr はコードを記述しなくてもデータの可視化や分析ができますのでデータ分析の初学者にとっては非常に便利な道具です。しかし、Rcmdr は R のごく一部のコマンド（関数）をGUIで使えるようにしたラッパーですので、できることが非常に限られています。加えてGUI操作が記録に残りませんので分析再現性の観点からみて好ましいとは言えません。 本格的なアドホック分析を行うには Rcmdr から卒業して R のスクリプトを書く必要があります。R 本体にはエディタ機能などが備わっていませんので統合開発環境（IDE - Integrated Development Environment）を利用すべきです。R における統合開発環境のデファクトスタンダードと言えるのが RStudio社の RStudio IDE （以降、RStudio） です。 Open Source Edition であれば基本的な機能は無償で利用できます。 "],
["rstudio-basics.html", "Chapter 4 RStudio Basics", " Chapter 4 RStudio Basics RStudio は 前述のように RStudio, Inc. が開発・公開している 統合開発環境（IDE）で R 用 IDE のデファクトスタンダードといえます。近年のバージョンアップにより R だけでなく Python や Stan などの言語もサポートも充実してきており、 R と Python の併用といったことも可能です。 初学者にとって便利な機能としては 強力なエディタ 様々な言語に対応するコードハイライティング 関数名のみならず変数名まで補完できるコード補完 キーひとつでヘルプの参照が可能など 分かりやすいパッケージ管理 インストール済パッケージの検索・読み込み インストールしたいパッケージ名の自動補完 プロジェクト管理 ディレクトリ単位でセパレートできるプロジェクト管理 VCSによる履歴管理 などがあります。R を利用したデータ分析を強力にサポートしてくれます。 "],
["rstudio-overview.html", "4.1 RStudio Overview", " 4.1 RStudio Overview RStudio の画面は大きく四つのエリア（以降、ペイン）から構成されます。 RStudio RStudio のバージョンにより多少ペイン構成が異なりますが以下のペインが用意されています。これらのペインはオプションで表示・非表示や表示位置を変更することができます。 No Pane name Descriptions 1 Source Editor ソースエディタ/ビューア（ファイルが開かれていない場合は未表示） 2 Console 文字通りRのコンソール（実行結果の表示だけでなくここから実行することも可） Terminal OSのターミナル（RStudio v1.1から） R Markdown R Markdownのレンダリング情報を表示 Jobs ローカルジョブの実行（RStudio v1.2から） 3 Help ヘルプの表示・検索が可能なヘルプビューア 4 History 実行履歴（コンソールでの実行、ソースからの実行共に記録） 5 Files 簡易なファイルマネージャ 6 Plots ヒストリ機能、プロット出力機能付きのプロットエリア（グラフィック専用） 7 Packages パッケージの管理を行うパッケージマネージャ 8 Environment 扱っているオブジェクト（変数、関数）の表示と参照ができる環境マネージャ 9 Viewer HTML等の表示が可能なビューア 10 VCS(Git/SVN) 簡易VCSクライアント（オプションでVCS(Git or SVN)を有効にしている場合のみ） 11 Build ビルドツール（プロジェクトオプションでBuildツールを有効にしている場合のみ） Connections データソース接続マネージャ（RStudio v1.1から） "],
["options.html", "4.2 Options", " 4.2 Options RStudio のオプション設定には Global Options と Project Options の二つの設定があります。 Global Options は文字通り RStudio 全体に対するオプション設定で、 Project Options は開いているプロジェクトのみに有効になるオプション設定です。オプション設定はデフォルトでも構いませんが、以下のように変更しておくことをおすゝめします。 4.2.1 Global Options メニュー［Tools］-［Global Options…］を選択すると表示できます。 大項目 中項目 小項目 設定内容等 General R version NA Windows版のみでOSのビット数に合わせる Default working directory NA Windows版のみ Code Editing Insert spaces for tab チェックする Tab width 2 Display Show line numbers チェックする Show margin チェックする Margin coloumn 80 Saving Line ending conversion Posix (LF) Default text encording UTF-8を選択 Packages CRAN mirror NA Golbal(CND) or Japan(Tokyo) Sweave Weave Rnw files using NA knitr Typeset LaTeX into PDF using NA XeLaTeX Terminal Connection Connect with WebSockts Terminalが起動しない場合はチェックを外す 4.2.2 Project Options メニュー［Tools］-［Project Options…］を選択すると表示できます。 大項目 中項目 設定内容等 General 必要に応じて変更します Code Editing Insert spaces for tab Global Optionと同設定を推奨 Tab width 同上 Line ending conversion 同上 Text encordint 同上 Sweave Weace Rnw files using 同上 Typeset LaTeX into PDF using 同上 Build Tools Project build tools 必要に応じて選択します Git/SVN Version control system 同上 Packrat Using packrat with this project Packratを利用する場合に使います "],
["keyboard-shortcuts.html", "4.3 Keyboard Shortcuts", " 4.3 Keyboard Shortcuts キーボードショートカットは効率的なコーディングに役立ちますので、最低限、以下のショートカットを覚えましょう。 Keyboard Shortcuts Description ［TAB］ 入力中のコード（オブジェクト）を補完 ［Alt/Option］+［-］ 代入演算子（&lt;-）をカーソル位置に挿入する ［Ctrl/Cmd］+［Shift］+［M］ パイプ演算子（%&gt;%）をカーソル位置に挿入する ［Ctrl/Cmd］+［Shift］+［C］ 選択行をコメント・アンコメントする（トグル動作） ［Ctrl/Cmd］+［Alt/Option］+［I］ カーソル位置にコードチャンクを挿入する（R Markdownのみ） ［Ctrl/Cmd］+［Enter］ 選択したコードを実行する（行選択、部分選択どちらも可） ［Ctrl/Cmd］+ [Sift] +［Enter］ コードチャンク内の全てのコードを実行する（R Markdownのみ） ［F1］ 選択またはカーソル位置の関数のヘルプを呼び出す ［Ctrl/Cmd］+［F］ アクティブなペイン内の検索 上記以外のショートカットはメニュー［Tools］-［Keyboard Shortcuts Help］を選択すると表示できます。 "],
["r-basics.html", "Chapter 5 R Basics", " Chapter 5 R Basics Rの一番良いところは統計学者が作っているところだ。 Rの一番悪いところは統計学者が作っているところだ。 出典 と言われる R ですが、最たる特徴は統計処理に特化している点です。また、前出の Data Science Workflow 全体をカバーできるようになっており、データ構造の変換や特定の分析に対する数々のパッケージ、コマンド一つでグラフが描ける高度なグラフィクス、更には分析結果をレポーティングするための仕組みも用意されています。 データ分析をひとつの言語で一気通貫できるので覚えることは非常に多岐に渡りますが、初学者が R を学ぶ際には、まず、「ベクトル演算」を理解するのが一つのポイントだと考えます。 "],
["overview.html", "5.1 Overview", " 5.1 Overview コーディングイメージを把握するための概要説明です。 2 * 3 # R Code ## [1] 6 5.1.1 四則演算 加減乗除算は他のプログラミング言語や電卓などと同じです。 1 + 2 [1] 3 2 - 3 [1] -1 3 * 4 [1] 12 4 / 5 [1] 0.8 5.1.2 四則演算結果の代入 次に演算結果を変数に代入してみます。代入演算子は&lt;-を使います。また、変数を使うための宣言は不要です。 w &lt;- 1 + 2 w ## [1] 3 x &lt;- 2 * 3 x ## [1] 6 y &lt;- 3 - 4 y ## [1] -1 z &lt;- 4 / 5 z ## [1] 0.8 5.1.3 変数同士の演算 演算結果を代入した変数同士の演算を行ってみます。 w + x ## [1] 9 x - y ## [1] 7 y * z ## [1] -0.8 z / w ## [1] 0.2666667 このようにRの基本は他のプログラミング言語と "],
["reserved-words.html", "5.2 Reserved words", " 5.2 Reserved words どの言語にも予約語といわれるものがあり、Rでは以下が予約語になっており変数名や関数名として使えません。 if, else, for, while, repeat, in, next, break, function TRUE, FALSE, NULL, NA, NaN, Inf NA_integer_, NA_real_, NA_complex_, NA_character_ TRUEとFALSEの省略形としてTとFが使えますが、この省略形を使うことはおすすめできません。理由は以下のコードを実行して確認してください。 T # Tの中身を確認する ## [1] TRUE F # Fの中身を確認する ## [1] FALSE class(T) # Tの型を確認する ## [1] &quot;logical&quot; find(&quot;T&quot;) # 定義されている場所を確認する ## [1] &quot;package:base&quot; T &lt;- 0 # Tに任意の値を代入する（数値でなく文字列でも可） T # 代入結果を確認する ## [1] 0 class(T) # Tの型を確認する ## [1] &quot;numeric&quot; find(&quot;T&quot;) # Tの定義を再確認する ## [1] &quot;.GlobalEnv&quot; &quot;package:base&quot; base::T # 元の定義はどうなった？ ## [1] TRUE では、予約語であるTRUEに対して同様のことをするとどうなるでしょう？ TRUE ## [1] TRUE class(TRUE) # 念の為に確認する ## [1] &quot;logical&quot; 以下は実際にご自分のコンソールで実行してみてください。 TRUE &lt;- 1 # 代入してみる ## Error in TRUE &lt;- 1: 代入の左辺が不正 (do_set) です rm(T) # 最後に掃除する "],
["variables.html", "5.3 Variables", " 5.3 Variables Rで変数を作成する場合、変数の型宣言や変数定義は必要ありません。何らかの値を代入した時点で値に応じた型の変数が自動的に作成されます。変数名の大文字/小文字は自動的に区別されますが数字から始まる変数名は作成できません。 var_num &lt;- 100 # 実数型 var_NUM &lt;- 7L # 整数を明示的に指定したい場合は数字に`L`をつける VAR_num &lt;- 13.5 # &quot;135e-1&quot;としても同じ var_cmp &lt;- 1 + 2i # 複素数も扱えます var_str &lt;- &quot;Strings&quot; # 文字列 var_STR &lt;- &quot;TRUE&quot; # &quot;&quot;で囲っているのでこれも文字列 var_bool &lt;- TRUE # 予約語として扱われるので論理型 var_BOOL &lt;- TRUE # 変数の大文字小文字は一文字でも異なれば異なる変数 VAR_bool &lt;- FALSE # 同上 var_date &lt;- as.Date(&quot;2016/1/1&quot;) # 日付型も扱えます 5.3.1 データ型 前述のコードを見てもわかるように変数を作成した場合はエラーがない限り何も応答がありませんので、変数の型（変数に入っているデータの型）を知るための基本的な方法を覚えておいてください。 [RStudio ][RS] を利用してる場合は［Environment］パネルで参照する方法ですが、コマンドラインで確認するにはbase::class関数を利用します。先程作成した変数を確認してみましょう。 class(var_num) ## [1] &quot;numeric&quot; class(var_NUM) ## [1] &quot;integer&quot; class(VAR_num) ## [1] &quot;numeric&quot; class(var_cmp) ## [1] &quot;complex&quot; class(var_str) ## [1] &quot;character&quot; class(var_STR) ## [1] &quot;character&quot; class(var_bool) ## [1] &quot;logical&quot; class(var_BOOL) ## [1] &quot;logical&quot; class(VAR_bool) ## [1] &quot;logical&quot; class(var_date) ## [1] &quot;Date&quot; 表示されたものは型（クラス）名です。変数型との対応は以下の通りになります。数字を代入した場合は自動的にnumericクラスになりますので、明示的に整数integerとして扱いたい場合は前述のようにnL(n: 整数)とLを添えて代入するか後述のbase::as.intger関数を用いてください。 型 クラス名 備考 数値型 numeric 実数、整数、まとめて複素数型を数値型と言う場合もあります 実数型 numeric 倍精度実数 整数型 integer 複素数型 complex 論理型 logical Boolean型 文字型 character 日付型 Date POSIX型もあります 5.3.2 class 5.3.3 変数型（変数の構造） [R ][R] は前述のような単純な変数（いわゆるスカラー型）だけでなく様々な構造をもった変数が扱えます。厳密にいえば [R ][R] ではいわゆるスカラー型の変数はなく、複数の値を入れられるベクトル型の変数が基本となります。今までの実行結果の頭に[1]というような表示があるのは変数に入っている値の数を示すためのインデックスです。いわゆるスカラー型はデータの個数が一つのベクトル型です。 [R ][R] で扱える基本的な変数型は以下の通りです。 変数の型 説明 ベクトル型 一つのデータ型を任意の個数扱える変数 マトリクス型（行列型） ベクトル型の一形態（特殊なベクトル型ともいえます） アレイ型（配列型） 同上 データフレーム型 データ型の異なるデータ数が同じ複数のベクトルを扱える変数 リスト型 データ型が異なりデータ数も異なる複数のベクトルを扱える変数 5.3.4 ベクトル型 ベクトル型は最も基本となる変数型（変数の構造）です。ベクトル型変数を作成するにはbase::c関数を利用します。 vec_num &lt;- c(1:10) # 連続した整数（1～10）として扱われます vec_NUM &lt;- c(1, 2, 3) # c(1:3)とはことなり実数値とした扱われます vec_cmp &lt;- c(1 + 0i, 2 + 3i, 3 + 5i) # 複素数型 vec_str &lt;- c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;VOID&quot;) # &quot;&quot;で囲んでいるので文字列 vec_bool &lt;- c(TRUE, FALSE) # 予約語として扱われる vec_BOOL &lt;- c(TRUE, FALSE, TRUE) 作成した変数の変数型と変数の値を確認してみましょう。同時に確認するにはbase::class関数ではなくbase::str関数を使います。 str(vec_num) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 str(vec_NUM) ## num [1:3] 1 2 3 str(vec_cmp) ## cplx [1:3] 1+0i 2+3i 3+5i str(vec_str) ## chr [1:3] &quot;TRUE&quot; &quot;FALSE&quot; &quot;VOID&quot; str(vec_bool) ## logi [1:2] TRUE FALSE str(vec_BOOL) ## logi [1:3] TRUE FALSE TRUE ベクトル型変数は単一のデータ型しか格納できない点に注意してください。データ型の異なる値を代入した場合は後述の強制型変換が行われます。 5.3.5 マトリクス型 マトリクス型は二次元配列のベクトル型変数と言えます。作成するにはbase::matrix関数を利用します。関数によってはベクトル型でなくマトリクス型の変数を引数にする必要がある場合がありますので、覚えておいてください。 mat_num &lt;- matrix(c(10, 20, 30, 40, 50, 60), 2, 3) mat_num ## [,1] [,2] [,3] ## [1,] 10 30 50 ## [2,] 20 40 60 mat_str &lt;- matrix(c(&quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;y&quot;), 2, 2) mat_str ## [,1] [,2] ## [1,] &quot;a&quot; &quot;x&quot; ## [2,] &quot;b&quot; &quot;y&quot; 5.3.6 アレイ型 アレイ型は多次元配列を扱える変数です。作成するにはbase::array関数を利用します。 # アレイ型 ary_num &lt;- array(c(1:12), c(2, 3, 2)) ary_num ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 5.3.7 データフレーム型 データフレーム型は [R ][R] の特徴でもありベクトル型と並んで最も重要な変数型です。データフレーム型ではデータ数の同じ異なるデータ型のベクトル変数を複数まとめて格納できる変数型です。イメージとししてはスプレッドシートを用いたデータテーブルのようなものです。 データフレーム型を作成するにはbase::data.frame関数を用います。デフォルトでは文字型変数は後述の因子型(Factor)として扱われます。 dataset &lt;- data.frame(vec_NUM, vec_str, vec_BOOL, vec_cmp) dataset 数の異なるデータからデータフレーム型を作るとどうなるでしょう？実際にご自分のコンソールで実行してみてください。 data_set &lt;- data.frame(vec_num, vec_str, vec_bool) 5.3.8 リスト型 リスト型はデータフレーム型と異なりデータ数の異なるデータ型の変数を複数まとめて格納できる変数型です。格納できる変数型（構造）はベクトル型に限らずマトリクス型やデータフレーム型、またリスト型自身も格納可能な柔軟は変数型です。関数の返り値としてよく使われますので多少厄介ではありますがリスト型変数内のデータの参照方法だけでも覚えておきましょう。 lst_num &lt;- list(c(1:10), c(0.5:5.5), seq(1, 4, 0.2)) lst_num ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] 0.5 1.5 2.5 3.5 4.5 5.5 ## ## [[3]] ## [1] 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 lst_mix &lt;- list(c(1:10), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), c(TRUE, FALSE)) lst_mix ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] TRUE FALSE ### 因子型 {#Factor} 因子型は”型”と書いていますが、変数型ではなく特殊な変数の構造です。因子型も[R][R]の特徴の一つでデータを層別する場合に有用であり、用途に応じた「順序あり」と「順序なし」の二種類の因子型があります。 因子型の種類 作成に利用する関数 順序なし因子 base::factor 順序あり因子 base::ordered var_fac &lt;- factor(&quot;Food&quot;) var_FAC &lt;- factor(10) vec_fac &lt;- factor(c(&quot;Fruit&quot;, &quot;Vegetable&quot;, &quot;Fruit&quot;)) vec_FAC &lt;- factor(c(1:5)) 作成した因子型の変数を確認してみましょう。 str(var_fac) ## Factor w/ 1 level &quot;Food&quot;: 1 str(var_FAC) ## Factor w/ 1 level &quot;10&quot;: 1 str(vec_fac) ## Factor w/ 2 levels &quot;Fruit&quot;,&quot;Vegetable&quot;: 1 2 1 str(vec_FAC) ## Factor w/ 5 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 2 3 4 5 このように同じ値は同じ因子とみなされていることが分かります。既に作成されている変数を因子型にすることも可能です。 VEC_fac &lt;- factor(vec_str) VEC_fac ## [1] TRUE FALSE VOID ## Levels: FALSE TRUE VOID vec_ord &lt;- ordered(vec_str) vec_ord ## [1] TRUE FALSE VOID ## Levels: FALSE &lt; TRUE &lt; VOID vec_ORD &lt;- factor(vec_num, ordered = TRUE) vec_ORD ## [1] 1 2 3 4 5 6 7 8 9 10 ## Levels: 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 5.3.9 特殊な定数 [R ][R] には予約語であるTRUEやFALSE以外にも変数に代入できる特別な意味をもった定数があります。 定数 説明 NULL 空 ＝ 何もない（何も存在しない）で、0(zero)や下記のNAとは異なります NA 欠損値（Not Available）。データの欠損（データが無いことを意味するデータです） NaN 非数（Not a Number）。数値では表現できないもの例えばlog(-1)とか0/0が該当します Inf 0(zero)除算時等は、NaNではなくInf/-Inf（無限大）になります 上記の特殊な定数を変数に代入してみましょう。 var_null &lt;- NULL var_na &lt;- NA var_nan &lt;- NaN var_inf &lt;- Inf 作成した変数のクラスを確認してみます。 class(var_null) ## [1] &quot;NULL&quot; class(var_na) ## [1] &quot;logical&quot; class(var_nan) ## [1] &quot;numeric&quot; class(var_inf) ## [1] &quot;numeric&quot; このように特殊な定数にも型（クラス）があることに留意しておいてください。 5.3.10 型を持ったNA 欠損値を示すNAには明示的に型を示すためのバリエーションがあります。これらも全て予約語になっています。 NA データ型 NA_integer_ 整数型 NA_real_ 実数型 NA_complex_ 複素数型 NA_character_ 文字型 5.3.11 強制型変換 さて、今までは変数を作成する際に常に同じデータ型のデータを指定してきましたが、データ型が混在するような変数を作成した場合どのようになるのでしょうか？まず、整数と実数が混在した場合の例を見てみます。データ型を確認するにはbase::typeof関数を使用します。 vec_test_0 &lt;- c(1L, 2L, 3L, 4L, 5L) typeof(vec_test_0) ## [1] &quot;integer&quot; vec_test_1 &lt;- c(1, 2L, 3.5, 4, 5L) typeof(vec_test_1) ## [1] &quot;double&quot; このように整数と実数が混在した場合は実数型として扱われます。次に実数と複素数が混在した場合はどのようになるのでしょうか？ vec_test_2 &lt;- c(1, 2 + 1i, 3, 4 + 3i) typeof(vec_test_2) ## [1] &quot;complex&quot; 整数と実数の混在のケースから容易に想像ができたとは思いますが、複素数型として扱われます。このように [R ][R] では変数を最適なデータ型に変換してくれます。これはベクトル型の変数では常に一つのデータ型しか保持できませんので強制的に型を変換することで一つの型とします。これを強制型変換といいます。 では、以下のような場合はどうなるでしょう。実際にやってみましょう。 vec_test_3 &lt;- c(1L, TRUE, 0L, FALSE) typeof(vec_test_3) vec_test_4 &lt;- c(&quot;String&quot;, 1L, TRUE, 0) typeof(vec_test_4) 強制型変換は下表のように左から右の優先順位で（柔軟性の高い方へ）型変換されます。 low high logical integer double complex character 5.3.12 特殊な定数の型変換 さて、特殊な定数であるNULL、NA、NaN、Infが強制型変換されるとどうなるのでしょう？ typeof(NULL) ## [1] &quot;NULL&quot; typeof(NA) ## [1] &quot;logical&quot; typeof(NaN) ## [1] &quot;double&quot; typeof(Inf) ## [1] &quot;double&quot; NULLは文字通りNULLですからデータとして存在しませんのでNULL自体の型変換は行われません。 vec_test_5 &lt;- c(1L, 2, 3 + 4i, NULL, &quot;5&quot;) typeof(vec_test_5) ## [1] &quot;character&quot; vec_test_5 ## [1] &quot;1&quot; &quot;2&quot; &quot;3+4i&quot; &quot;5&quot; 一方、NA, NaN, Infは上記の通りデータ型を持っていますので型変換が行われます。 vec_test_6 &lt;- c(1L, 2, 3 + 4i, NULL, NaN, NA, Inf) typeof(vec_test_6) ## [1] &quot;complex&quot; vec_test_6 ## [1] 1+0i 2+0i 3+4i NaN+0i NA Inf+0i なぜ、このような事になるかはこちらの参考資料 にてご確認ください。 5.3.13 変数の参照 変数に代入したデータを参照する方法は変数型により多少ことなります。ベクトル型やマトリクス型では変数内の任意のデータを参照する場合、[]や$という演算子の一種であるアクセス演算子を用います。では、変数型で作成した変数を使って具体的に確認してみましょう。 5.3.14 ベクトル型変数 ベクトル型、マトリクス型、アレイ型変数内のデータを参照する場合[]を利用します。 vec_str ## [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;VOID&quot; vec_str[3] ## [1] &quot;VOID&quot; mat_num ## [,1] [,2] [,3] ## [1,] 10 30 50 ## [2,] 20 40 60 mat_num[3] ## [1] 30 mat_num[1, ] ## [1] 10 30 50 mat_num[, 2] ## [1] 30 40 mat_num[2, 3] ## [1] 60 [n]と指定した場合n番目のデータを参照し、[n, ]と指定場合n行のデータを参照し、[, n]と指定した場合n列のデータを参照します。アレイ型の場合は多次元配列ですので指定する数値が多くなる点に注意してください。 ary_num ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 ary_num[8] ## [1] 8 ary_num[, , 2] ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 ary_num[1, , 2] ## [1] 7 9 11 ary_num[, 3, 2] ## [1] 11 12 5.3.15 データフレーム型変数 データフレーム型変数内のベクトル型変数を参照する場合は$を用います。更に参照したベクトル型変数内のデータを参照する場合には前述の[]を利用します。 dataset dataset$vec_NUM ## [1] 1 2 3 dataset$vec_str[3] ## [1] VOID ## Levels: FALSE TRUE VOID 5.3.16 リスト型変数 リスト型変数を参照する場合は[[]]を用います。names属性がある場合はデータフレーム型と同様に$を用いることが可能です。 lst_mix ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] TRUE FALSE lst_mix[[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; lst_mix[[2]][2] ## [1] &quot;b&quot; 5.3.17 変数の扱い方 [R ][R] の変数で最も注意すべき点は、再代入により変数のデータ型は書き換えられてしまう場合があることです。例えば最初に整数型の変数として作成したvec_numですが、以下のような代入を行うとデータ型が変わってしまうことがわかります。 str(vec_num) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 vec_num &lt;- c(&quot;char&quot;) str(vec_num) ## chr &quot;char&quot; 5.3.18 変数型を確認する 前述のようなことを避けるにはbase::is.*関数を用いることでデータ型の検査（確認）をすることができます。 is.numeric(vec_num) ## [1] FALSE vec_num &lt;- c(1:10) is.numeric(vec_num) ## [1] TRUE is.integer(vec_num) ## [1] TRUE 論理型 整数型 実数型 数値型 複素数型 文字型 is.logical is.integer is.double is.numeric is.complex is.character base::is.numeric関数は数値か否かを検査するので整数型に対してもTRUEを返すことに注意してください。 また、データ型だけでなく変数型も変更してしまうことができますので変数型を検査する場合もbase::is.*関数を利用してください。 ベクトル型 マトリクス型 アレイ型 リスト型 データフレーム型 is.vector is.matrix is.array is.list is.data.frame 因子型 順序あり因子型 is.factor is.ordered 5.3.19 参考）定数を確認する 特殊な定数に対する検査を行う関数も用意されています。 NULL 欠損値 非数 有限 無限 id.null is.na is.nan is.finit is.infinit "],
["operator.html", "5.4 Operator", " 5.4 Operator [R ][R] の特徴はなんと行ってもベクトル演算が行えることです。これによりループ文を用いて面倒な演算処理を記述することなくベクトル型変数の演算が可能です。 5.4.1 単項演算子 単項演算子は文字通り1つの対象（オブジェクト）に作用する演算子です。 [R ][R] における単項演算子は-（マイナス）ならびに!（否定, NOT）があります。 VAR_num ## [1] 13.5 -VAR_num ## [1] -13.5 !TRUE ## [1] FALSE 5.4.2 算術演算子 算術演算子（二項演算子）は演算の基本中の基本とも言える四則演算である加算、減算、乗算、除算、ならびに、べき算（べき乗）、整数除算（商、剰余）の六つの演算子です。では実際に演算を行ってみましょう。 a &lt;- c(1:10) b &lt;- c(10:1) a ## [1] 1 2 3 4 5 6 7 8 9 10 b ## [1] 10 9 8 7 6 5 4 3 2 1 a + b ## [1] 11 11 11 11 11 11 11 11 11 11 a - b ## [1] -9 -7 -5 -3 -1 1 3 5 7 9 a * b ## [1] 10 18 24 28 30 30 28 24 18 10 a / b ## [1] 0.1000000 0.2222222 0.3750000 0.5714286 0.8333333 1.2000000 ## [7] 1.7500000 2.6666667 4.5000000 10.0000000 a ^ b ## [1] 1 512 6561 16384 15625 7776 2401 512 81 10 a %/% b ## [1] 0 0 0 0 0 1 1 2 4 10 a %% b ## [1] 1 2 3 4 5 1 3 2 1 0 5.4.3 比較演算子 比較演算子は関係演算子とも呼ばれる2つの対象（オブジェクト）の関係を調べる演算子で、同値関係を調べる等号記号や順序関係を調べる不等号などがこれにあたります。返り値は論理型となります。 小なり 大なり 以下 以上 等しい 等しくない &lt; &gt; &lt;= &gt;= == != 算術演算子と同様にベクトル型変数に適用可能です。 a ## [1] 1 2 3 4 5 6 7 8 9 10 b ## [1] 10 9 8 7 6 5 4 3 2 1 a &lt; b ## [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE a &gt; b ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE a == b ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE a != b ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 5.4.4 論理演算子 論理演算子は2つの対象（オブジェクト）のブール関数を評価するものです。論理和(AND)・論理積(OR)はベクトルを対象とするか否かで演算子が異なりますので注意してください。 AND OR ベクトルAND ベクトルOR XOR NOT TRUEか否か &amp;&amp; || &amp; | xor ! isTRUE y &lt;- c(TRUE, FALSE, TRUE, FALSE) z &lt;- c(TRUE, TRUE, FALSE, FALSE) y &amp;&amp; z ## [1] TRUE y &amp; z ## [1] TRUE FALSE FALSE FALSE y || z ## [1] TRUE y | z ## [1] TRUE TRUE TRUE FALSE xor(y, z) ## [1] FALSE TRUE TRUE FALSE !y ## [1] FALSE TRUE FALSE TRUE TRUEか否かはbase::isTRUE関数でも確認できます。FALSEか否かを確認する関数はありませんので、否定演算子!と組み合わせてください。 isTRUE(TRUE) ## [1] TRUE !isTRUE(FALSE) ## [1] TRUE ただし、base::isTRUE関数は以下の条件を満たす時のみ正しい値を返すことに注意してください。 変数の長さが1であること 変数の長さが1を超えている場合は全てTRUEであること 変数にnames等の属性が付加されていないこと ベクトルの個々の値に対してbase:isTRUEを適用したい場合はbase::sapply関数を用います。 y ## [1] TRUE FALSE TRUE FALSE sapply(y, isTRUE) ## [1] TRUE FALSE TRUE FALSE 5.4.5 特殊演算子 特殊演算子は%文字と%文字で挟まれた演算子です。前述の整数除算（商、剰余）厳密にいえば特殊演算子になりますが本資料では算術演算子として記載しています。なお、 [R ][R] の特殊演算子は任意の演算子を定義することができますのでパッケージによっては特殊演算子を用意している場合もあります。なお、 [R ][R] の基本パッケージで用意されている特殊演算子には以下のようなものがあります。 特殊演算子 演算内容 %*% 内積（スカラー積） %in% マッチング %o% 外積（ベクトル積） %x% クロネッカー積 5.4.6 演算子の優先順位 演算子の優先順位は下表の通りとなります。優先順位を変えたい場合は()を利用して明示的に指定をしてください。下記以外はヘルプでSyntaxと検索すると確認できます。 演算子 説明 順位 $ 要素へのアクセス（データフレーム型、リスト型） 高 [], [[]] 要素へのアクセス（ベクトル型、マトリクス型、アレイ型、リスト型） ^ べき乗 - マイナス（単項演算子） : 等差数列（c(1:10）のような数列） %% 特殊演算子（二項演算子） *, / 乗算、除算（二項演算子） +, - 加算、減算（二項演算子） &lt;, &gt;, &lt;=, &gt;= 比較演算子（順序関係） ==, != 比較演算子（同値関係） ! 否定（論理演算子） &amp;, |, &amp;&amp;, || 論理積、論理和（論理演算子） &lt;&lt;- 永続代入（グローバル変数への代入） &lt;- 代入 低 "],
["control-制御文.html", "5.5 Control （制御文）", " 5.5 Control （制御文） [R ][R] における条件分岐（制御文）と繰り返し（ループ文）基本的に他の言語と同様で予約語になっています。 5.5.1 条件分岐 [R ][R] の基本的な条件分岐は以下の3つがあります。 文・関数 説明 if else 基本的な条件分岐処理 switch 条件が多数に分岐する場合に便利な条件分岐処理 base::ifelse ExcelのIF関数に似た条件分岐処理でベクトル化された引数が扱える 5.5.2 if, else if文とelse文は最も基本的な条件分岐です。評価式には論理演算子または論理型変数を用います。コーディングスタイルとして以下のどちらも可能ですが、後者のスタイルの方を推奨します。 if (var_bool != TRUE) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) ## [1] &quot;FALSE&quot; if (var_bool == TRUE) { print(&quot;TRUE&quot;) } else { print(&quot;FALSE&quot;) } ## [1] &quot;TRUE&quot; if文は入れ子にしてもelse if文として組み合わせて使うことも可能ですが、評価式は必ずTRUEかFALSEが単一で返るようにしなければなりません。 if (is.logical(var_bool)) { print(&quot;Logical variable&quot;) if (var_bool == TRUE) { print(&quot;TRUE&quot;) } else { print(&quot;FALSE&quot;) } } else if (is.numeric(var_bool)) { print(&quot;Numeric variable&quot;) } else { print(&quot;Unknown variable&quot;) } ## [1] &quot;Logical variable&quot; ## [1] &quot;TRUE&quot; 5.5.3 switch 分岐する条件の数が多い場合はif文でなくswitch*文を利用するのが便利です。if文と同じで評価式はTRUEかFALSEが単一で返るようにしなければなりません。 switch(1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;Error&quot;) ## [1] &quot;A&quot; switch(6, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;Error&quot;) ## [1] &quot;Error&quot; switch(8, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;Error&quot;) 5.5.4 ifelse base::ifelseは予約語でなく関数です。if文と異なるのはベクトル型の評価が一度に行える点です。第一引数にTRUEかFALSEが返る評価式であればベクトル型でも構いません。 vec_BOOL ## [1] TRUE FALSE TRUE ifelse(vec_BOOL, &quot;Yes&quot;, &quot;No&quot;) ## [1] &quot;Yes&quot; &quot;No&quot; &quot;Yes&quot; ifelse(is.na(vec_BOOL), &quot;Yes&quot;, &quot;No&quot;) ## [1] &quot;No&quot; &quot;No&quot; &quot;No&quot; 5.5.5 繰り返し 繰り返しは文字通り処理を任意の回数繰り返す場合に用いるもので予約語になっています。繰り返し文の処理は時間がかかるため [R ][R] においては好ましくなく繰り返しは使わずベクトル演算で処理すべきと言われていますが、 [R ][R]-3.4.0からJITコンパイラと呼ばれる繰り返し処理の高速化がデフォルトで有効化されており今後は処理記述の流れが変わる可能性があります。処理の高速化についてはこちらの 参考資料 で確認してください。なお、繰り返し処理で注意すべき点は繰り返し文中では明示的に出力を指定しないと計算結果等が出力されない点です。 [R ][R] の繰り返しには以下の3つがあります。 文 説明 for 条件式に与えたベクトルやリストが空になるまで任意の回数繰り返す while 条件式に与えた条件が成立している限り繰り返す repeat 無限に繰り返すが繰り返し処理中のbreak文で繰り返しを終了できる また、繰り返しを条件式以外で変更する処理用の文として以下が用意されています。これらも予約語です。 文 説明 next この文が実行された時点で強制的に次の繰り返し処理に入ります break この文が実行された時点で繰り返し処理を終了します 5.5.6 for for文は最も基本となる繰り返し処理で、条件式としてベクトルやリストを与える点が他の言語と異なる点です。 for (i in c(1:5, 7, 9:15)) { if (i == 4) { next } else if (i &gt;= 10) { break } else { print(as.character(i)) } } ## [1] &quot;1&quot; ## [1] &quot;2&quot; ## [1] &quot;3&quot; ## [1] &quot;5&quot; ## [1] &quot;7&quot; ## [1] &quot;9&quot; 5.5.7 while, repeat while文とrepeat文については、あまり使うこともないと思いますので省略します。 "],
["import.html", "Chapter 6 Import ", " Chapter 6 Import "],
["readr.html", "6.1 readr", " 6.1 readr "],
["readxl.html", "6.2 readxl", " 6.2 readxl "],
["pdftools.html", "6.3 pdftools", " 6.3 pdftools "],
["tidy.html", "Chapter 7 Tidy ", " Chapter 7 Tidy "],
["tidy-data.html", "7.1 Tidy Data", " 7.1 Tidy Data "],
["longer.html", "7.2 longer", " 7.2 longer "],
["wider.html", "7.3 wider", " 7.3 wider "],
["transform.html", "Chapter 8 Transform ", " Chapter 8 Transform "],
["filter.html", "8.1 filter", " 8.1 filter "],
["rename.html", "8.2 rename", " 8.2 rename "],
["select.html", "8.3 select", " 8.3 select 8.3.1 select helpers "],
["mutate.html", "8.4 mutate", " 8.4 mutate "],
["summarize.html", "8.5 summarize", " 8.5 summarize "],
["base-r.html", "Chapter 9 Base R", " Chapter 9 Base R "],
["ggplot2.html", "Chapter 10 ggplot2", " Chapter 10 ggplot2 "],
["r-markdown.html", "Chapter 11 R Markdown", " Chapter 11 R Markdown "]
]
