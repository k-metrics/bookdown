[
["r-basics.html", "Chapter 4 R Basics", " Chapter 4 R Basics Rの一番良いところは統計学者が作っているところだ。 Rの一番悪いところは統計学者が作っているところだ。 出典 と言われる R ですが、最たる特徴は統計処理に特化している点です。また、前出の Data Science Workflow 全体をカバーできるようになっており、データ構造の変換や特定の分析に対する数々のパッケージ、コマンド一つでグラフが描ける高度なグラフィクス、更には分析結果をレポーティングするための仕組みも用意されています。 データ分析をひとつの言語で一気通貫できるので覚えることは非常に多岐に渡りますが、初学者が R を学ぶ際には、まず、「ベクトル演算」を理解するのが一つのポイントだと考えます。 "],
["overview.html", "4.1 Overview", " 4.1 Overview コーディングイメージを把握するための概要説明です。 R は他のプログラミング言語と同じく、変数と演算子、そして関数・制御文を用いてコーディングします。 4.1.1 四則演算 加減乗除算は他のプログラミング言語や電卓などと同じです。 1 + 2 [1] 3 2 - 3 [1] -1 3 * 4 [1] 12 4 / 5 [1] 0.8 4.1.2 四則演算結果の代入 次に演算結果を変数に代入してみます。代入演算子は&lt;-を使います。また、変数を使うための宣言は不要です。 w &lt;- 1 + 2 w ## [1] 3 x &lt;- 2 * 3 x ## [1] 6 y &lt;- 3 - 4 y ## [1] -1 z &lt;- 4 / 5 z ## [1] 0.8 4.1.3 変数同士の演算 演算結果を代入した変数同士の演算を行ってみます。 w + x ## [1] 9 x - y ## [1] 7 y * z ## [1] -0.8 z / w ## [1] 0.2666667 このようにRの基本は他のプログラミング言語と "],
["reserved-words.html", "4.2 Reserved words", " 4.2 Reserved words どの言語にも予約語といわれるものがあり、Rでは以下が予約語になっており変数名や関数名として使えません。 if, else, for, while, repeat, in, next, break, function TRUE, FALSE, NULL, NA, NaN, Inf NA_integer_, NA_real_, NA_complex_, NA_character_ TRUEとFALSEの省略形としてTとFが使えますが、この省略形を使うことはおすすめできません。理由は以下のコードを実行して確認してください。 T # Tの中身を確認する ## [1] TRUE F # Fの中身を確認する ## [1] FALSE class(T) # Tの型を確認する ## [1] &quot;logical&quot; find(&quot;T&quot;) # 定義されている場所を確認する ## [1] &quot;package:base&quot; T &lt;- 0 # Tに任意の値を代入する（数値でなく文字列でも可） T # 代入結果を確認する ## [1] 0 class(T) # Tの型を確認する ## [1] &quot;numeric&quot; find(&quot;T&quot;) # Tの定義を再確認する ## [1] &quot;.GlobalEnv&quot; &quot;package:base&quot; base::T # 元の定義はどうなった？ ## [1] TRUE では、予約語であるTRUEに対して同様のことをするとどうなるでしょう？ TRUE ## [1] TRUE class(TRUE) # 念の為に確認する ## [1] &quot;logical&quot; 以下は実際にご自分のコンソールで実行してみてください。 TRUE &lt;- 1 # 代入してみる ## Error in TRUE &lt;- 1: 代入の左辺が不正 (do_set) です rm(T) # 最後に掃除する "],
["variables.html", "4.3 Variables", " 4.3 Variables Rで変数を作成する場合、変数の型宣言や変数定義は必要ありません。何らかの値を代入した時点で値に応じた型の変数が自動的に作成されます。変数名の大文字/小文字は自動的に区別されますが数字から始まる変数名は作成できません。 var_num &lt;- 100 # 実数型 var_NUM &lt;- 7L # 整数を明示的に指定したい場合は数字に`L`をつける VAR_num &lt;- 13.5 # &quot;135e-1&quot;としても同じ var_cmp &lt;- 1 + 2i # 複素数も扱えます var_str &lt;- &quot;Strings&quot; # 文字列 var_STR &lt;- &quot;TRUE&quot; # &quot;&quot;で囲っているのでこれも文字列 var_bool &lt;- TRUE # 予約語として扱われるので論理型 var_BOOL &lt;- TRUE # 変数の大文字小文字は一文字でも異なれば異なる変数 VAR_bool &lt;- FALSE # 同上 var_date &lt;- as.Date(&quot;2016/1/1&quot;) # 日付型も扱えます 4.3.1 データ型 前述のコードを見てもわかるように変数を作成した場合はエラーがない限り何も応答がありませんので、変数の型（変数に入っているデータの型）を知るための基本的な方法を覚えておいてください。 [RStudio ][RS] を利用してる場合は［Environment］パネルで参照する方法ですが、コマンドラインで確認するにはbase::class関数を利用します。先程作成した変数を確認してみましょう。 class(var_num) ## [1] &quot;numeric&quot; class(var_NUM) ## [1] &quot;integer&quot; class(VAR_num) ## [1] &quot;numeric&quot; class(var_cmp) ## [1] &quot;complex&quot; class(var_str) ## [1] &quot;character&quot; class(var_STR) ## [1] &quot;character&quot; class(var_bool) ## [1] &quot;logical&quot; class(var_BOOL) ## [1] &quot;logical&quot; class(VAR_bool) ## [1] &quot;logical&quot; class(var_date) ## [1] &quot;Date&quot; 表示されたものは型（クラス）名です。変数型との対応は以下の通りになります。数字を代入した場合は自動的にnumericクラスになりますので、明示的に整数integerとして扱いたい場合は前述のようにnL(n: 整数)とLを添えて代入するか後述のbase::as.intger関数を用いてください。 型 クラス名 備考 数値型 numeric 実数、整数、まとめて複素数型を数値型と言う場合もあります 実数型 numeric 倍精度実数 整数型 integer 複素数型 complex 論理型 logical Boolean型 文字型 character 日付型 Date POSIX型もあります 4.3.2 class 4.3.3 変数型（変数の構造） [R ][R] は前述のような単純な変数（いわゆるスカラー型）だけでなく様々な構造をもった変数が扱えます。厳密にいえば [R ][R] ではいわゆるスカラー型の変数はなく、複数の値を入れられるベクトル型の変数が基本となります。今までの実行結果の頭に[1]というような表示があるのは変数に入っている値の数を示すためのインデックスです。いわゆるスカラー型はデータの個数が一つのベクトル型です。 [R ][R] で扱える基本的な変数型は以下の通りです。 変数の型 説明 ベクトル型 一つのデータ型を任意の個数扱える変数 マトリクス型（行列型） ベクトル型の一形態（特殊なベクトル型ともいえます） アレイ型（配列型） 同上 データフレーム型 データ型の異なるデータ数が同じ複数のベクトルを扱える変数 リスト型 データ型が異なりデータ数も異なる複数のベクトルを扱える変数 4.3.4 ベクトル型 ベクトル型は最も基本となる変数型（変数の構造）です。ベクトル型変数を作成するにはbase::c関数を利用します。 vec_num &lt;- c(1:10) # 連続した整数（1～10）として扱われます vec_NUM &lt;- c(1, 2, 3) # c(1:3)とはことなり実数値とした扱われます vec_cmp &lt;- c(1 + 0i, 2 + 3i, 3 + 5i) # 複素数型 vec_str &lt;- c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;VOID&quot;) # &quot;&quot;で囲んでいるので文字列 vec_bool &lt;- c(TRUE, FALSE) # 予約語として扱われる vec_BOOL &lt;- c(TRUE, FALSE, TRUE) 作成した変数の変数型と変数の値を確認してみましょう。同時に確認するにはbase::class関数ではなくbase::str関数を使います。 str(vec_num) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 str(vec_NUM) ## num [1:3] 1 2 3 str(vec_cmp) ## cplx [1:3] 1+0i 2+3i 3+5i str(vec_str) ## chr [1:3] &quot;TRUE&quot; &quot;FALSE&quot; &quot;VOID&quot; str(vec_bool) ## logi [1:2] TRUE FALSE str(vec_BOOL) ## logi [1:3] TRUE FALSE TRUE ベクトル型変数は単一のデータ型しか格納できない点に注意してください。データ型の異なる値を代入した場合は後述の強制型変換が行われます。 4.3.5 マトリクス型 マトリクス型は二次元配列のベクトル型変数と言えます。作成するにはbase::matrix関数を利用します。関数によってはベクトル型でなくマトリクス型の変数を引数にする必要がある場合がありますので、覚えておいてください。 mat_num &lt;- matrix(c(10, 20, 30, 40, 50, 60), 2, 3) mat_num ## [,1] [,2] [,3] ## [1,] 10 30 50 ## [2,] 20 40 60 mat_str &lt;- matrix(c(&quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;y&quot;), 2, 2) mat_str ## [,1] [,2] ## [1,] &quot;a&quot; &quot;x&quot; ## [2,] &quot;b&quot; &quot;y&quot; 4.3.6 アレイ型 アレイ型は多次元配列を扱える変数です。作成するにはbase::array関数を利用します。 # アレイ型 ary_num &lt;- array(c(1:12), c(2, 3, 2)) ary_num ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 4.3.7 データフレーム型 データフレーム型は [R ][R] の特徴でもありベクトル型と並んで最も重要な変数型です。データフレーム型ではデータ数の同じ異なるデータ型のベクトル変数を複数まとめて格納できる変数型です。イメージとししてはスプレッドシートを用いたデータテーブルのようなものです。 データフレーム型を作成するにはbase::data.frame関数を用います。デフォルトでは文字型変数は後述の因子型(Factor)として扱われます。 dataset &lt;- data.frame(vec_NUM, vec_str, vec_BOOL, vec_cmp) dataset 数の異なるデータからデータフレーム型を作るとどうなるでしょう？実際にご自分のコンソールで実行してみてください。 data_set &lt;- data.frame(vec_num, vec_str, vec_bool) 4.3.8 リスト型 リスト型はデータフレーム型と異なりデータ数の異なるデータ型の変数を複数まとめて格納できる変数型です。格納できる変数型（構造）はベクトル型に限らずマトリクス型やデータフレーム型、またリスト型自身も格納可能な柔軟は変数型です。関数の返り値としてよく使われますので多少厄介ではありますがリスト型変数内のデータの参照方法だけでも覚えておきましょう。 lst_num &lt;- list(c(1:10), c(0.5:5.5), seq(1, 4, 0.2)) lst_num ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] 0.5 1.5 2.5 3.5 4.5 5.5 ## ## [[3]] ## [1] 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 lst_mix &lt;- list(c(1:10), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), c(TRUE, FALSE)) lst_mix ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] TRUE FALSE ### 因子型 {#Factor} 因子型は”型”と書いていますが、変数型ではなく特殊な変数の構造です。因子型も[R][R]の特徴の一つでデータを層別する場合に有用であり、用途に応じた「順序あり」と「順序なし」の二種類の因子型があります。 因子型の種類 作成に利用する関数 順序なし因子 base::factor 順序あり因子 base::ordered var_fac &lt;- factor(&quot;Food&quot;) var_FAC &lt;- factor(10) vec_fac &lt;- factor(c(&quot;Fruit&quot;, &quot;Vegetable&quot;, &quot;Fruit&quot;)) vec_FAC &lt;- factor(c(1:5)) 作成した因子型の変数を確認してみましょう。 str(var_fac) ## Factor w/ 1 level &quot;Food&quot;: 1 str(var_FAC) ## Factor w/ 1 level &quot;10&quot;: 1 str(vec_fac) ## Factor w/ 2 levels &quot;Fruit&quot;,&quot;Vegetable&quot;: 1 2 1 str(vec_FAC) ## Factor w/ 5 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 2 3 4 5 このように同じ値は同じ因子とみなされていることが分かります。既に作成されている変数を因子型にすることも可能です。 VEC_fac &lt;- factor(vec_str) VEC_fac ## [1] TRUE FALSE VOID ## Levels: FALSE TRUE VOID vec_ord &lt;- ordered(vec_str) vec_ord ## [1] TRUE FALSE VOID ## Levels: FALSE &lt; TRUE &lt; VOID vec_ORD &lt;- factor(vec_num, ordered = TRUE) vec_ORD ## [1] 1 2 3 4 5 6 7 8 9 10 ## Levels: 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 4.3.9 特殊な定数 [R ][R] には予約語であるTRUEやFALSE以外にも変数に代入できる特別な意味をもった定数があります。 定数 説明 NULL 空 ＝ 何もない（何も存在しない）で、0(zero)や下記のNAとは異なります NA 欠損値（Not Available）。データの欠損（データが無いことを意味するデータです） NaN 非数（Not a Number）。数値では表現できないもの例えばlog(-1)とか0/0が該当します Inf 0(zero)除算時等は、NaNではなくInf/-Inf（無限大）になります 上記の特殊な定数を変数に代入してみましょう。 var_null &lt;- NULL var_na &lt;- NA var_nan &lt;- NaN var_inf &lt;- Inf 作成した変数のクラスを確認してみます。 class(var_null) ## [1] &quot;NULL&quot; class(var_na) ## [1] &quot;logical&quot; class(var_nan) ## [1] &quot;numeric&quot; class(var_inf) ## [1] &quot;numeric&quot; このように特殊な定数にも型（クラス）があることに留意しておいてください。 4.3.10 型を持ったNA 欠損値を示すNAには明示的に型を示すためのバリエーションがあります。これらも全て予約語になっています。 NA データ型 NA_integer_ 整数型 NA_real_ 実数型 NA_complex_ 複素数型 NA_character_ 文字型 4.3.11 強制型変換 さて、今までは変数を作成する際に常に同じデータ型のデータを指定してきましたが、データ型が混在するような変数を作成した場合どのようになるのでしょうか？まず、整数と実数が混在した場合の例を見てみます。データ型を確認するにはbase::typeof関数を使用します。 vec_test_0 &lt;- c(1L, 2L, 3L, 4L, 5L) typeof(vec_test_0) ## [1] &quot;integer&quot; vec_test_1 &lt;- c(1, 2L, 3.5, 4, 5L) typeof(vec_test_1) ## [1] &quot;double&quot; このように整数と実数が混在した場合は実数型として扱われます。次に実数と複素数が混在した場合はどのようになるのでしょうか？ vec_test_2 &lt;- c(1, 2 + 1i, 3, 4 + 3i) typeof(vec_test_2) ## [1] &quot;complex&quot; 整数と実数の混在のケースから容易に想像ができたとは思いますが、複素数型として扱われます。このように [R ][R] では変数を最適なデータ型に変換してくれます。これはベクトル型の変数では常に一つのデータ型しか保持できませんので強制的に型を変換することで一つの型とします。これを強制型変換といいます。 では、以下のような場合はどうなるでしょう。実際にやってみましょう。 vec_test_3 &lt;- c(1L, TRUE, 0L, FALSE) typeof(vec_test_3) vec_test_4 &lt;- c(&quot;String&quot;, 1L, TRUE, 0) typeof(vec_test_4) 強制型変換は下表のように左から右の優先順位で（柔軟性の高い方へ）型変換されます。 low high logical integer double complex character 4.3.12 特殊な定数の型変換 さて、特殊な定数であるNULL、NA、NaN、Infが強制型変換されるとどうなるのでしょう？ typeof(NULL) ## [1] &quot;NULL&quot; typeof(NA) ## [1] &quot;logical&quot; typeof(NaN) ## [1] &quot;double&quot; typeof(Inf) ## [1] &quot;double&quot; NULLは文字通りNULLですからデータとして存在しませんのでNULL自体の型変換は行われません。 vec_test_5 &lt;- c(1L, 2, 3 + 4i, NULL, &quot;5&quot;) typeof(vec_test_5) ## [1] &quot;character&quot; vec_test_5 ## [1] &quot;1&quot; &quot;2&quot; &quot;3+4i&quot; &quot;5&quot; 一方、NA, NaN, Infは上記の通りデータ型を持っていますので型変換が行われます。 vec_test_6 &lt;- c(1L, 2, 3 + 4i, NULL, NaN, NA, Inf) typeof(vec_test_6) ## [1] &quot;complex&quot; vec_test_6 ## [1] 1+0i 2+0i 3+4i NaN+0i NA Inf+0i なぜ、このような事になるかはこちらの参考資料 にてご確認ください。 4.3.13 変数の参照 変数に代入したデータを参照する方法は変数型により多少ことなります。ベクトル型やマトリクス型では変数内の任意のデータを参照する場合、[]や$という演算子の一種であるアクセス演算子を用います。では、変数型で作成した変数を使って具体的に確認してみましょう。 4.3.14 ベクトル型変数 ベクトル型、マトリクス型、アレイ型変数内のデータを参照する場合[]を利用します。 vec_str ## [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;VOID&quot; vec_str[3] ## [1] &quot;VOID&quot; mat_num ## [,1] [,2] [,3] ## [1,] 10 30 50 ## [2,] 20 40 60 mat_num[3] ## [1] 30 mat_num[1, ] ## [1] 10 30 50 mat_num[, 2] ## [1] 30 40 mat_num[2, 3] ## [1] 60 [n]と指定した場合n番目のデータを参照し、[n, ]と指定場合n行のデータを参照し、[, n]と指定した場合n列のデータを参照します。アレイ型の場合は多次元配列ですので指定する数値が多くなる点に注意してください。 ary_num ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 ary_num[8] ## [1] 8 ary_num[, , 2] ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 ary_num[1, , 2] ## [1] 7 9 11 ary_num[, 3, 2] ## [1] 11 12 4.3.15 データフレーム型変数 データフレーム型変数内のベクトル型変数を参照する場合は$を用います。更に参照したベクトル型変数内のデータを参照する場合には前述の[]を利用します。 dataset dataset$vec_NUM ## [1] 1 2 3 dataset$vec_str[3] ## [1] VOID ## Levels: FALSE TRUE VOID 4.3.16 リスト型変数 リスト型変数を参照する場合は[[]]を用います。names属性がある場合はデータフレーム型と同様に$を用いることが可能です。 lst_mix ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] TRUE FALSE lst_mix[[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; lst_mix[[2]][2] ## [1] &quot;b&quot; 4.3.17 変数の扱い方 [R ][R] の変数で最も注意すべき点は、再代入により変数のデータ型は書き換えられてしまう場合があることです。例えば最初に整数型の変数として作成したvec_numですが、以下のような代入を行うとデータ型が変わってしまうことがわかります。 str(vec_num) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 vec_num &lt;- c(&quot;char&quot;) str(vec_num) ## chr &quot;char&quot; 4.3.18 変数型を確認する 前述のようなことを避けるにはbase::is.*関数を用いることでデータ型の検査（確認）をすることができます。 is.numeric(vec_num) ## [1] FALSE vec_num &lt;- c(1:10) is.numeric(vec_num) ## [1] TRUE is.integer(vec_num) ## [1] TRUE 論理型 整数型 実数型 数値型 複素数型 文字型 is.logical is.integer is.double is.numeric is.complex is.character base::is.numeric関数は数値か否かを検査するので整数型に対してもTRUEを返すことに注意してください。 また、データ型だけでなく変数型も変更してしまうことができますので変数型を検査する場合もbase::is.*関数を利用してください。 ベクトル型 マトリクス型 アレイ型 リスト型 データフレーム型 is.vector is.matrix is.array is.list is.data.frame 因子型 順序あり因子型 is.factor is.ordered 4.3.19 参考）定数を確認する 特殊な定数に対する検査を行う関数も用意されています。 NULL 欠損値 非数 有限 無限 id.null is.na is.nan is.finit is.infinit "],
["operator.html", "4.4 Operator", " 4.4 Operator [R ][R] の特徴はなんと行ってもベクトル演算が行えることです。これによりループ文を用いて面倒な演算処理を記述することなくベクトル型変数の演算が可能です。 4.4.1 単項演算子 単項演算子は文字通り1つの対象（オブジェクト）に作用する演算子です。 [R ][R] における単項演算子は-（マイナス）ならびに!（否定, NOT）があります。 VAR_num ## [1] 13.5 -VAR_num ## [1] -13.5 !TRUE ## [1] FALSE 4.4.2 算術演算子 算術演算子（二項演算子）は演算の基本中の基本とも言える四則演算である加算、減算、乗算、除算、ならびに、べき算（べき乗）、整数除算（商、剰余）の六つの演算子です。では実際に演算を行ってみましょう。 a &lt;- c(1:10) b &lt;- c(10:1) a ## [1] 1 2 3 4 5 6 7 8 9 10 b ## [1] 10 9 8 7 6 5 4 3 2 1 a + b ## [1] 11 11 11 11 11 11 11 11 11 11 a - b ## [1] -9 -7 -5 -3 -1 1 3 5 7 9 a * b ## [1] 10 18 24 28 30 30 28 24 18 10 a / b ## [1] 0.1000000 0.2222222 0.3750000 0.5714286 0.8333333 1.2000000 ## [7] 1.7500000 2.6666667 4.5000000 10.0000000 a ^ b ## [1] 1 512 6561 16384 15625 7776 2401 512 81 10 a %/% b ## [1] 0 0 0 0 0 1 1 2 4 10 a %% b ## [1] 1 2 3 4 5 1 3 2 1 0 4.4.3 比較演算子 比較演算子は関係演算子とも呼ばれる2つの対象（オブジェクト）の関係を調べる演算子で、同値関係を調べる等号記号や順序関係を調べる不等号などがこれにあたります。返り値は論理型となります。 小なり 大なり 以下 以上 等しい 等しくない &lt; &gt; &lt;= &gt;= == != 算術演算子と同様にベクトル型変数に適用可能です。 a ## [1] 1 2 3 4 5 6 7 8 9 10 b ## [1] 10 9 8 7 6 5 4 3 2 1 a &lt; b ## [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE a &gt; b ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE a == b ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE a != b ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 4.4.4 論理演算子 論理演算子は2つの対象（オブジェクト）のブール関数を評価するものです。論理和(AND)・論理積(OR)はベクトルを対象とするか否かで演算子が異なりますので注意してください。 AND OR ベクトルAND ベクトルOR XOR NOT TRUEか否か &amp;&amp; || &amp; | xor ! isTRUE y &lt;- c(TRUE, FALSE, TRUE, FALSE) z &lt;- c(TRUE, TRUE, FALSE, FALSE) y &amp;&amp; z ## [1] TRUE y &amp; z ## [1] TRUE FALSE FALSE FALSE y || z ## [1] TRUE y | z ## [1] TRUE TRUE TRUE FALSE xor(y, z) ## [1] FALSE TRUE TRUE FALSE !y ## [1] FALSE TRUE FALSE TRUE TRUEか否かはbase::isTRUE関数でも確認できます。FALSEか否かを確認する関数はありませんので、否定演算子!と組み合わせてください。 isTRUE(TRUE) ## [1] TRUE !isTRUE(FALSE) ## [1] TRUE ただし、base::isTRUE関数は以下の条件を満たす時のみ正しい値を返すことに注意してください。 変数の長さが1であること 変数の長さが1を超えている場合は全てTRUEであること 変数にnames等の属性が付加されていないこと ベクトルの個々の値に対してbase:isTRUEを適用したい場合はbase::sapply関数を用います。 y ## [1] TRUE FALSE TRUE FALSE sapply(y, isTRUE) ## [1] TRUE FALSE TRUE FALSE 4.4.5 特殊演算子 特殊演算子は%文字と%文字で挟まれた演算子です。前述の整数除算（商、剰余）厳密にいえば特殊演算子になりますが本資料では算術演算子として記載しています。なお、 [R ][R] の特殊演算子は任意の演算子を定義することができますのでパッケージによっては特殊演算子を用意している場合もあります。なお、 [R ][R] の基本パッケージで用意されている特殊演算子には以下のようなものがあります。 特殊演算子 演算内容 %*% 内積（スカラー積） %in% マッチング %o% 外積（ベクトル積） %x% クロネッカー積 4.4.6 演算子の優先順位 演算子の優先順位は下表の通りとなります。優先順位を変えたい場合は()を利用して明示的に指定をしてください。下記以外はヘルプでSyntaxと検索すると確認できます。 演算子 説明 順位 $ 要素へのアクセス（データフレーム型、リスト型） 高 [], [[]] 要素へのアクセス（ベクトル型、マトリクス型、アレイ型、リスト型） ^ べき乗 - マイナス（単項演算子） : 等差数列（c(1:10）のような数列） %% 特殊演算子（二項演算子） *, / 乗算、除算（二項演算子） +, - 加算、減算（二項演算子） &lt;, &gt;, &lt;=, &gt;= 比較演算子（順序関係） ==, != 比較演算子（同値関係） ! 否定（論理演算子） &amp;, |, &amp;&amp;, || 論理積、論理和（論理演算子） &lt;&lt;- 永続代入（グローバル変数への代入） &lt;- 代入 低 "],
["control-制御文.html", "4.5 Control （制御文）", " 4.5 Control （制御文） [R ][R] における条件分岐（制御文）と繰り返し（ループ文）基本的に他の言語と同様で予約語になっています。 4.5.1 条件分岐 [R ][R] の基本的な条件分岐は以下の3つがあります。 文・関数 説明 if else 基本的な条件分岐処理 switch 条件が多数に分岐する場合に便利な条件分岐処理 base::ifelse ExcelのIF関数に似た条件分岐処理でベクトル化された引数が扱える 4.5.2 if, else if文とelse文は最も基本的な条件分岐です。評価式には論理演算子または論理型変数を用います。コーディングスタイルとして以下のどちらも可能ですが、後者のスタイルの方を推奨します。 if (var_bool != TRUE) print(&quot;TRUE&quot;) else print(&quot;FALSE&quot;) ## [1] &quot;FALSE&quot; if (var_bool == TRUE) { print(&quot;TRUE&quot;) } else { print(&quot;FALSE&quot;) } ## [1] &quot;TRUE&quot; if文は入れ子にしてもelse if文として組み合わせて使うことも可能ですが、評価式は必ずTRUEかFALSEが単一で返るようにしなければなりません。 if (is.logical(var_bool)) { print(&quot;Logical variable&quot;) if (var_bool == TRUE) { print(&quot;TRUE&quot;) } else { print(&quot;FALSE&quot;) } } else if (is.numeric(var_bool)) { print(&quot;Numeric variable&quot;) } else { print(&quot;Unknown variable&quot;) } ## [1] &quot;Logical variable&quot; ## [1] &quot;TRUE&quot; 4.5.3 switch 分岐する条件の数が多い場合はif文でなくswitch*文を利用するのが便利です。if文と同じで評価式はTRUEかFALSEが単一で返るようにしなければなりません。 switch(1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;Error&quot;) ## [1] &quot;A&quot; switch(6, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;Error&quot;) ## [1] &quot;Error&quot; switch(8, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;Error&quot;) 4.5.4 ifelse base::ifelseは予約語でなく関数です。if文と異なるのはベクトル型の評価が一度に行える点です。第一引数にTRUEかFALSEが返る評価式であればベクトル型でも構いません。 vec_BOOL ## [1] TRUE FALSE TRUE ifelse(vec_BOOL, &quot;Yes&quot;, &quot;No&quot;) ## [1] &quot;Yes&quot; &quot;No&quot; &quot;Yes&quot; ifelse(is.na(vec_BOOL), &quot;Yes&quot;, &quot;No&quot;) ## [1] &quot;No&quot; &quot;No&quot; &quot;No&quot; 4.5.5 繰り返し 繰り返しは文字通り処理を任意の回数繰り返す場合に用いるもので予約語になっています。繰り返し文の処理は時間がかかるため [R ][R] においては好ましくなく繰り返しは使わずベクトル演算で処理すべきと言われていますが、 [R ][R]-3.4.0からJITコンパイラと呼ばれる繰り返し処理の高速化がデフォルトで有効化されており今後は処理記述の流れが変わる可能性があります。処理の高速化についてはこちらの 参考資料 で確認してください。なお、繰り返し処理で注意すべき点は繰り返し文中では明示的に出力を指定しないと計算結果等が出力されない点です。 [R ][R] の繰り返しには以下の3つがあります。 文 説明 for 条件式に与えたベクトルやリストが空になるまで任意の回数繰り返す while 条件式に与えた条件が成立している限り繰り返す repeat 無限に繰り返すが繰り返し処理中のbreak文で繰り返しを終了できる また、繰り返しを条件式以外で変更する処理用の文として以下が用意されています。これらも予約語です。 文 説明 next この文が実行された時点で強制的に次の繰り返し処理に入ります break この文が実行された時点で繰り返し処理を終了します 4.5.6 for for文は最も基本となる繰り返し処理で、条件式としてベクトルやリストを与える点が他の言語と異なる点です。 for (i in c(1:5, 7, 9:15)) { if (i == 4) { next } else if (i &gt;= 10) { break } else { print(as.character(i)) } } ## [1] &quot;1&quot; ## [1] &quot;2&quot; ## [1] &quot;3&quot; ## [1] &quot;5&quot; ## [1] &quot;7&quot; ## [1] &quot;9&quot; 4.5.7 while, repeat while文とrepeat文については、あまり使うこともないと思いますので省略します。 "]
]
